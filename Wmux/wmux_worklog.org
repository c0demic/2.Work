#+TITLE: wmux worklog
#+AUTHOR: Lixin Yu
#+OPTIONS: ^:nil
#+LATEX: \newpage

* 20170503
** magit					  :auxiliaryWork:emacs:magit:
Manage to use magit in emacs to accelerate the speed of orgnizing my worklog
** wmux								  :idea:wmux:
The wmux is short for Web mux, kind of feeling like tmux. It means I hope the web can be split into several different workspace as user expects.
** DONE add account					    :cluster:account:
The account can not be added because my account on datacenter is not in the sudoers file and i can't run cmgui.
- I add 2 accounts:
  - dominik schleicher: pwd: 123456
  - jinhua he: pwd: 123456
The users will be the one who will make simulations on the cluster.
** TODO lustre file not mounted				    :cluster:problem:
   SCHEDULED: <2017-05-03 Wed>
* 20170504
* 20170505
** structure of build tool chain of firefly			      :tools:
I figure out how the gradle works with nodejs and how nodejs organize the frontend js files
*** how gradle works					       :gradle:tools:
Gradle are organized through build.gradle file. In build.gradle file, you can use plugins and add library as you need. 
The most import plugin of nodejs in gradle is gradle-node-plugin. 
The plugin can be used by adding the following line to the build.gradle file:
#+BEGIN_SRC gradle
plugins{
    id "com.moowork.node" version "1.1.1"
}

apply plugins: 'com.moowork.node'
#+END_SRC
**** In Intellij Idea, if you add the above contents to the default build.gradle file. It will complain that the plugins{} is wrong and only plugins{} or script{} can be added before plugins{}. 
Solution: delete the first line of comments will solve the problem
**** The comments in gradle file
- //
- /* ... */
*** how nodejs works					       :nodejs:tools:
If you want to use react and redux things like that, you should understand how they are transformed into the final bundle.js file.
You write javascript file using JSX format, then you need babel to use .babelrc configuration file to transform the JSX file into some other form of standard javascript language:
(babel) JSX------>Standard javascript
The standard javascript file will then be bundled by webpack using webpack.config.js file
(webpack) Javascript ------> bundle.js
* 20170506
** communication
Javascript can communicate with java using websocket or socket.io
nodejs can communication with java using redis(pub/sub)
** structure of wmux
We can use both nodejs and java as backend together with the help of redis or something like that or we can use java as backend and communicate with javascript using websocket as firefly does.
** package.json
The most important part is the package name and version. The yarn and npm will write in the same package.json file without knowing each other in different way.
** npm vs yarn					      :nodejs:npm:yarn:tools:
The yarn is faster, I know nothing more.
*** install
yarn add <package> [ ||--dev]
npm install [-g] <package>  --save||--save-dev
yarn add <package> ~ n
** webpack					       :nodejs:webpack:tools:
Webpack is a tool to reorganize the js file based on dependency relationship of js file.
Usually each page can have only one entrance js file, but you can add more entrance js file using multiple entrypoint file. It is relativly complex.
See the [[https://webpack.github.io/docs/multiple-entry-points.html][webpack multiple-entry-points link]].

* 20170507
I build up the whole work place for wmux which include:
- gradle
- webpack
- babel
- react
- redux
* 20170508
** babel-loader find directory recursively 	      :problem:babel:webpack:
By inspecting the webpage using toggle tools, I found that the jsx file in subdirectory is also compiled and integrated into bundle.js.
The problem is how to use css to modify the component.
** CSS							       :css:ui:react:
The css can be defined in each jsx file and i think this is reasonable because according to definition of css, it is assumed to work as cascade structure and thus making it in the very lower level would overwrite the upper level css specification and it is very rational.
** Pictures: file-loader			   :file-loader:loader:react:
The file loader is a good thing to display picture on web which is better than image-webpack-plugin that suffers some strange problem related with ENOENT or something it depends on.
One notation is to notice that the file-loader should set the name of the output file including the directory path. The relative path is relative to the public path of the output parameter of webpack and the public path is a relative path to the path that the output file specified.
** TODO The multi-entry problem 
 
* 20170509
** CSS							       :css:ui:react:
The following link may be a guide:
[[andrewhfarmer.com/how-to-style-react/][react-style-guide]]
According to this guide, SCSS + autoprefixer [+ BEM] should be okay for me.
But as I feel if I can make the css style inline with react would be very helpful, I would like to choose a inline css plugin and that is radium besides material-ui library will also be used.
** ES7								 :future:ES7:
ES7 adds decoration in  it and you need babel-plugin-syntax-decorators to be compatible with it and you need to modify the .babelrc into the following:
#+BEGIN_SRC
{
    "presets": ["es2015", "react"],
    "plugins": ["transform-class-properties",
                "syntax-decorators"
               ]
}
#+END_SRC
** packages installed
*** overlist
['babel-plugin-transform-es2015-classes','babel-plugin-transform-decorators-legacy','radium','prop-types','babel-plugin-syntax-decorators', 'path','mozjpeg','pngquant','url-loader','img-loader','material-ui','paper','image-webpack-loader','file-loader', 'react', 'jsx', 'react-dom', 'redux','babel-cli', 'babel-loader', 'babel-core', 'babel-preset-es2015','babel-preset-es2017', 'babel-preset-react','babel-preset-stage-0','babel-preset-stage-1','babel-preset-stage-2', 'webpack', '--dev']
*** prop-types 						   :package:comments:
I install the package because the react complains that the accessing propTypes via react is deprecated in react v15.5 and later, you need to use prop-types package instead.
The warning will be display even you don't call proptypes in the react code, because you may call it independently.
*** babel-preset-2017
Js evolved very fast, the es2017 provide a lot of new features and I need to embrace it ASAP.
Feature like new way to initial class is more concise than that in es6 and es5.
*** babel-plugin-transform-decorators-legacy
This is kind of an official plugin for decorators, because decorators is new feature in es2017 not in es2015.
*** radium						   :CSS:radium:react:
This is the inline css plugin I will use and because I choose inline css plugin, so I can't and don't have to choose other type of css plugin like SCSS or BEM or any other non-inline css plugins.
radium will be unmounted because it is replaced by aphrodite and css_module plugins plus a method called [[ITCSS]].
*** babel-plugin-transform-es2015-classes
The plugin is used to solve the problem that the class should declare constructor with new which Radium doesn't do it this way.

*** material-ui
This is a very powerful ui plugin I will use and it will save me time in design plugins.
*** paper 
This is needed by material at least some components in material.
*** img-loader, mozjpeg, pngquant, image-webpack-loader
These are removed form package list because they are replaced by file-loader. At the very beginning, they are supposed to provide the function to show images on the web but they failed.
*** 
** webpack							    :webpack:
In webpack config file webpack.config.js, you can't use both "query" and "options", query is deprecated and you should use options only.

** package.json
in the last, there is code like this:
#+BEGIN_SRC json

"scripts": {
    "build": "webpack"
  },

"babel": {
    "presets": [
      "es2015"
    ]
  }
#+END_SRC
The scripts part can not be removed because the webpack will have to read it. But the babel part is not necessary for webpack and should be able to be removed easily.
** what I learn today by now
*** es2017
es2017 has a better feature in setting the constructor of a class but radium can not use it.
*** webpack.config.js
The config file should only use "options" as a key parameter, at least you can't use "options" with "query" together, that will cause the problem of webpack process.
*** inline CSS
As I believe it is most suitable to use CSS in the component, I think use inline CSS is a wise choise and I would use Radium to do the job.
*** material-ui
The material-ui is a class of gui thing which is carefully designed and should save a lot of time in building the website.
*** IIFE
IIFE will have great influence on the conditionals in JSX. See this link[[http://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript][IIFE]]. 
** TODO draw the framwork of the ideal website and at least realize the first edition before end of tomorrow.
* 20170510
** CSS					    :css:aphrodite:css_module:ITTCSS:
I met a lot of problem in radium and when I try to figure out the problem of inline css with SASS I found aphrodite. There is a good [[https://medium.com/maintainable-react-apps/journey-to-enjoyable-maintainable-styling-with-react-itcss-and-css-in-js-632cfa9c70d6][article]] talking about the css best practice. So I decide to change to this best practice.
*** aphrodite
*** css_module
*** <<ITCSS>>
ITCSS is inversed trangle CSS. It is not a framework nor a software, it is a principle by which the developers should follow in order to keep your css scalable, terse, logical and managable.
*** material-ui							:material_ui:
material-ui may use BEM principle which require you to name the components with PascalCamel rules.
*** loader		       :loader:webpack:config:js_loader:babel_loader:
To load the jsx file, you might need jsx-loader, but it is not for sure, I suspect you don't need that, but if you use it, put it before babel-loader.
*** less-loader
When you use css, some plugins might have less inside it so you need to install less-loader to load less file.
You might also have chance to meeet other requirement which you will have to meet them according to webpack error report.

* 20170511
** groupmeeting
No much progress made and they want to make more changes on both hardware and software. We need to decide it later.
*** move one computing node to provide service
*** change to HDFS
*** change BCM to free software
** talk with chunhui
Progress is not quick enough. I may have to put more attention on it.
** fix path problem
The resolve.root method is deprecated and I use resolve.alias to give the absolute path of the app root directory.
** use import instead of var=require
The import method is imported to ES6 recently and it is advanced than require method which is used in commonJS.
* 20170515
** react route is able to change the current page without refresh the page
** the structure of the web is clear when I was in Gerado's office
** CSS related
*** put div on right side of page
See the link [[http://stackoverflow.com/questions/5222523/position-a-div-container-on-the-right-side][positionOnRight]].

* 20170516
Works are updated on github, so here will miss something. Last week, I need to stay in office in cerro Calan. Efficiency is a little lower.
** summary of knowledge of react redirect
- browserHistory can and can only be imported by history package, react-router v4 doesn't provide it.
- history push will have a "#" in front of the path desired.
- browserHistory.push might no be able to use, it complains that the _history.browserHistory is undefined.
- window.location.href="</path/to/dir.html>"
  - remember that the </path/to/dir.html>:
    - if it begins with a slash "/", it is the absolute path relative to the website root URL;
    - if it begins without a slash "/", it is relative to the current URL. This is dangerous because you may find it hard to use the relative path, it can easily got you into trouble because you are not in the URL that supposed to be.
  - you may find that using varible in window.location is very convenient when bundled with search bar. You can find some information from [[http://stackoverflow.com/questions/28250103/react-how-to-navigate-via-clickhandlers][here]]. 
- transition is used only for internal URL. If you want to transfer to other domain use window.location or <a href=''>
- Even if you can declare: 
#+BEGIN_SRC
contextTypes:{
  router: React.PropTypes.object
}
#+END_SRC
without problem, you still cannot use this.context.router.push('<url>'), the browser will complain context.router is undefined
- ??figure out Redict usage
- context.router exists only in react-router v>2 rc2 or v<1 rc3
* 20170517
** redux review

*** action
- action are plain js object;
- action creator is a plain function that return action
**** dispatch
Dispatch is a function that dispatch a function, it can take parameter to complete the action, but finally it is just a plain function.
**** bindActionCreators
A function that bind several actions creators with one dispatcher

*** Reducer
A function tell what state should be returned when a action is dispatched.
**** Reducer Decomposition
You need to decompose the reducer into small part that make the maintainance easy. The main reducer need to call the decomposed reducer in the routine.
***** combineReducers
After you decompose the reducer into small part, you may combine them into one reducer using combineReducers function.
****** key in combineReducers
You can assign a key to combineReducers and each reducer only deal with the slice of state defined by the key. e.g.:
#+BEGIN_SRC
const reducer = combineReducers({
  a: doSomethingWithA,
  b: processB,
  c: c
})
#+END_SRC
which equals: 
#+BEGIN_SRC
function reducer(state = {}, action) {
  return {
    a: doSomethingWithA(state.a, action),
    b: processB(state.b, action),
    c: c(state.c, action)
  }
}
#+END_SRC
** react-redux flow deepin
The whole story is very tricky and only practice and reading the code can make you really understand them, but the flow is much more clearer this time:
*** state
The state that will show on the page.
*** action							      :redux:
Indicate what you want to do with the state.
*** reducer							      :redux:
The only way to change the state.
*** combine reducers
You can and should decompose the reducer into small ones, and then use combineReducers function to combine them all into one single reducer.
*** REACT UI						  :react:react_redux:
**** presentational component
Only show what you can see
**** container component
How the presentational component work
*** store						  :redux:react_redux:
Store is a thing that you can generate by calling createStore(rootReducer).
*** connect						  :react_redux:redux:
Connect is a function that connect the state and dispatch with props of component.
*** provider						  :react_redux:redux:
Provider can provide the reducer to the component, and then the reducer can change the state. After the state is changed into a new one, the state will be updated and the props will be updated and the page will refresh.
*** subscribe
Subscribe is a function that can make the listener know that state has changed and the listener will be called at the moment the state is refreshed.
